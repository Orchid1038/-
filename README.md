# Java Algorithms

這個 Repo 包含了使用 Java 實作的各種演算法,適合在 LeetCode 等線上判題系統練習。演算法按類別分類,下面將逐一說明。

## 目錄

- [遞迴 (Recursion)](#遞迴-recursion)
- [樹的遍歷 (Tree Traversal)](#樹的遍歷-tree-traversal)
- [深度/廣度優先搜尋 (DFS/BFS)](#深度廣度優先搜尋-dfsbfs)
- [動態規劃 (Dynamic Programming)](#動態規劃-dynamic-programming)
- [分治法 (Divide and Conquer)](#分治法-divide-and-conquer)
- [二分搜尋 (Binary Search)](#二分搜尋-binary-search)
- [雙指標 (Two Pointers)](#雙指標-two-pointers)
- [組合 (Combination)](#組合-combination)
- [滑動窗口 (Sliding Window)](#滑動窗口-sliding-window)
- [回溯法 (Backtracking)](#回溯法-backtracking)
- [排序算法 (Sorting Algorithms)](#排序算法-sorting-algorithms)
- [貪婪法 (Greedy)](#貪婪法-greedy)
- [資料結構 (Data Structures)](#資料結構-data-structures)
- [其他 (Others)](#其他-others)

## 遞迴 (Recursion)

將問題切分成相同的小問題,直到小問題可以直接解決為止。

## 樹的遍歷 (Tree Traversal)

包含前序、中序、後序和層序遍歷,可使用 DFS 或 BFS 實現。

## 深度/廣度優先搜尋 (DFS/BFS)

按深度或廣度遍歷所有資料。

## 動態規劃 (Dynamic Programming)

通常應用在求解最大/最小值或計算方案數量的問題。

## 分治法 (Divide and Conquer)

將問題分解為相同的小問題,分別解決後合併結果。

## 二分搜尋 (Binary Search)

在已排序資料中尋找目標值,時間複雜度 O(logN)。

## 雙指標 (Two Pointers)

通常應用在陣列,使用前後兩個指標來比較資料。

## 組合 (Combination)

從所有可能的組合中找出最佳解。

## 滑動窗口 (Sliding Window)

解決連續資料區間的相關問題,如子字串、子陣列等。

## 回溯法 (Backtracking)

## 排序算法 (Sorting Algorithms)

- 選擇排序 (Selection Sort)
- 氣泡排序 (Bubble Sort)
- 插入排序 (Insertion Sort)
- 堆積排序 (Heap Sort)
- 桶排序 (Bucket Sort)
- 計數排序 (Counting Sort)
- 基數排序 (Radix Sort)

## 貪婪法 (Greedy)

每次選擇當前最優解,直到問題被解決。

## 資料結構 (Data Structures)

- 集合 (Set)
- 映射 (Map/HashMap)
- 堆疊 (Stack)
- 佇列 (Queue)
- 雙端佇列 (Deque)
- 單調堆疊 (Monotonic Stack)
- 二元搜尋樹 (Binary Search Tree)
- 圖 (Graph)
- 並查集 (Disjoint Set/Union Find)
- 最小生成樹 (Minimal Spanning Tree)
- Trie
- 優先佇列 (Priority Queue)
- 二元索引樹 (Binary Indexed Tree)
- 線段樹 (Segment Tree)

## 其他 (Others)

- 暴力解 (Brute Force)
- 數學解 (Math Solution)
- 隨機化 (Randomized)
- 位元運算 (Bit Manipulation)
- 前綴和 (Prefix Sum)
- 子集和 (Subset Sum)
- 區間 (Interval)
- 掃描線 (Line Sweep)
- 二元提升 (Binary Lifting)
- 雙掃描 (Two Pass)
